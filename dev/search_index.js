var documenterSearchIndex = {"docs":
[{"location":"#MutatingOrNot","page":"Home","title":"MutatingOrNot","text":"Documentation for MutatingOrNot.\n\n","category":"section"},{"location":"#MutatingOrNot.dryrun","page":"Home","title":"MutatingOrNot.dryrun","text":"dryrun is the only instance of the singleton type BasicDryRun. When passed as an output argument, it is meant to signal that one wants to allocate that output argument, but not to do actual work. See void and has_dryrun.\n\n\n\n\n\n","category":"constant"},{"location":"#MutatingOrNot.void","page":"Home","title":"MutatingOrNot.void","text":"void is the only instance of the singleton type BasicVoid <: Void. When passed as an output argument, it is meant to signal that this argument is not allocated, and needs to be. See Void, similar! and has_dryrun.\n\n\n\n\n\n","category":"constant"},{"location":"#MutatingOrNot.BasicDryRun","page":"Home","title":"MutatingOrNot.BasicDryRun","text":"struct BasicDryRun <: DryRun end\n\nSee DryRun.\n\n\n\n\n\n","category":"type"},{"location":"#MutatingOrNot.BasicVoid","page":"Home","title":"MutatingOrNot.BasicVoid","text":"struct BasicVoid <: Void end\n\nSee Void.\n\n\n\n\n\n","category":"type"},{"location":"#MutatingOrNot.DryRun","page":"Home","title":"MutatingOrNot.DryRun","text":"abstract type DryRun<:Void end\n\nInstances v of types subtyping DryDryn, especially dryrun, when passed as an output argument, are meant to signal that this argument needs to be allocated, but that no actual computation should take place. See has_dryrun.\n\n\n\n\n\n","category":"type"},{"location":"#MutatingOrNot.Void","page":"Home","title":"MutatingOrNot.Void","text":"abstract type Void end\n\nInstances v of types subtyping Void, especially void, when passed as an output argument, are meant to signal that this argument is not allocated, and needs to be. The aim is to implement both mutating and non-mutating styles in a single place, while facilitating the pre-allocation of output arguments before calling the mutating, non-allocating variant.\n\nTo facilitate this, the following behavior is implemented whenever v::Void\n\n(; x, y, z) = v results in x==v etc.\nx, y, z = v results in x==v etc.\n@. v = expr returns @. expr\n\nSee also similar! and has_dryrun.\n\n\n\n\n\n","category":"type"},{"location":"#MutatingOrNot.has_dryrun-Tuple{Any}","page":"Home","title":"MutatingOrNot.has_dryrun","text":"has_dryrun(x) returns\n\ntrue if x::DryRun,\nany(has_dryrun, x) if x is a (named) tuple,\nand false otherwise.\n\nUse it to avoid computations when only allocations are desired. Example:\n\nfunction f!(x, y, z)\n    # allocations, if needed\n    a = similar!(x.a, y)\n    b = similar!(x.b, z)\n\n    # early exit, if requested\n    has_dryrun(x) && return (; a, b)\n\n    # computations\n    a = @. a = y*y\n    b = @. b = exp(z)\n    return (; a, b)\nend\n\nIn the above example,\n\nthe special properties of x_::Void (see Void) are used\nx = f!(void, y) is the non-mutating variant of f!\nx = f!(dryrun, y) just allocates x, without performing actual work\nx = f!(x, y) mutates the pre-allocated x (non-allocating)\n\n\n\n\n\n","category":"method"},{"location":"#MutatingOrNot.similar!-Tuple{Any, Vararg{Any}}","page":"Home","title":"MutatingOrNot.similar!","text":"xx = similar!(x, y...)\n\nConvenience function that replaces more concisely:\n\nif x::Void\n    xx = similar(y...)\nelse\n    xx = x\nend\n\nThe goal is to allocate xx only when a pre-allocated x is not provided. similar(y...) defaults to Base.similar(y...) and similar(y) applies recursively to tuples and named tuples.\n\nSee also has_dryrun.\n\n\n\n\n\n","category":"method"},{"location":"#MutatingOrNot.similar-Tuple","page":"Home","title":"MutatingOrNot.similar","text":"x = similar(y...)\n\nsimilar(y...) defaults to Base.similar(y...). Furthermore the single-argument similar(y) applies recursively to tuples and named tuples. Contrary to Base.similar, it is not possible to specify eltype or dims in this recursive variant.\n\n\n\n\n\n","category":"method"},{"location":"#MutatingOrNot.Allocators.dumb","page":"Home","title":"MutatingOrNot.Allocators.dumb","text":"The singleton dumb describes the simplest possible allocation strategy:\n\nmalloc(dumb, args...) == similar(args...)\nmfree(dumb) = nothing\n\nEspecially, freeing memory is actually left to Julia's garbage collector.\n\n\n\n\n\n","category":"constant"},{"location":"#MutatingOrNot.Allocators.ArrayAllocator","page":"Home","title":"MutatingOrNot.Allocators.ArrayAllocator","text":"Parent type for array allocators. An instance tmp::ArrayAllocator is to be used along the following pattern:\n\ny = malloc(tmp, args...) # allocate temporary array y\n... # do some computation with y\nmfree(tmp, y) # `free` array y, in a sense depending on tmp\n\n\n\n\n\n","category":"type"},{"location":"#MutatingOrNot.Allocators.SmartAllocator-Tuple{}","page":"Home","title":"MutatingOrNot.Allocators.SmartAllocator","text":"smart = SmartAllocator()\n\nReturn a smart allocator smart, with the following behavior:\n\ninternally, smart maintains a store tracking previously allocated arrays,  marked as either busy or free.\ny = malloc(smart, args...) searches that store for an array  with the appropriate eltype and shape. If this fails,  it allocates one with similar(args...). Either way, y is marked as busy in the store.\nmfree(smart, y) keeps y in the store and marks it as free, so that a later call to malloc can reuse it\nany mfree must have a corresponding malloc\nmfree(smart) marks all arrays in the store as free but does not actually free anything.\nonly empty!(smart) actually empties the store, allowing Julia's garbage collector to act. \n\nNote of caution:\n\narrays from the store are reused only if they have the exact same eltype and shape as requested by malloc.\nto avoid runaway memory usage, any malloc must have a corresponding mfree\nthis allocator is smart only if the eltype and shape requested via malloc belong to a small set of possibilities.\n\n\n\n\n\n","category":"method"},{"location":"#MutatingOrNot.Allocators.malloc","page":"Home","title":"MutatingOrNot.Allocators.malloc","text":"y = malloc(tmp, args...)\n\nReturn array y, similarly to similar(args...). The allocator tmp may provide more or less sophisticated allocation strategies. See dumb and SmartAllocator.\n\n\n\n\n\n","category":"function"},{"location":"#MutatingOrNot.Allocators.mfree-Tuple{Any}","page":"Home","title":"MutatingOrNot.Allocators.mfree","text":"mfree(tmp)\n\nFree allocator tmp. Whether anything is actually done depends on the allocator tmp. See dumb and SmartAllocator.\n\n\n\n\n\n","category":"method"},{"location":"#MutatingOrNot.Allocators.mfree-Tuple{MutatingOrNot.Void, Any}","page":"Home","title":"MutatingOrNot.Allocators.mfree","text":"mfree(tmp, y)\n\nFree array y, which was previously allocated by malloc. Whether anything is actually done depends on the allocator tmp. See dumb and SmartAllocator.\n\n\n\n\n\n","category":"method"}]
}
