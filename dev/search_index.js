var documenterSearchIndex = {"docs":
[{"location":"#MutatingOrNot","page":"Home","title":"MutatingOrNot","text":"Documentation for MutatingOrNot.\n\n","category":"section"},{"location":"#MutatingOrNot.dryrun","page":"Home","title":"MutatingOrNot.dryrun","text":"dryrun is the only instance of the singleton type BasicDryRun. When passed as an output argument, it is meant to signal that one wants to allocate that output argument, but not to do actual work. Indeed:\n\nhas_dryrun(dryrun) == true\n\nSee void and has_dryrun.\n\n\n\n\n\n","category":"constant"},{"location":"#MutatingOrNot.void","page":"Home","title":"MutatingOrNot.void","text":"void is the only instance of the singleton type BasicVoid <: Void. When passed as an output argument, it is meant to signal that this argument is not allocated, and needs to be. Moreover:\n\nhas_dryrun(void)  == false\nset_dryrun(void) == dryrun\n\nSee Void, DryRun.\n\n\n\n\n\n","category":"constant"},{"location":"#MutatingOrNot.ArrayAllocator","page":"Home","title":"MutatingOrNot.ArrayAllocator","text":"Parent type for array allocators. Array allocators can be passed as output arguments  instead of preallocated arrays needed for intermediate computations. For instance:\n\nfunction myfun1(tmp::Union{AbstractArray, ArrayAllocator}, input)\n    x = malloc(tmp, ...) # allocate temporary array y, as with `similar(...)`\n    ...\n    ret = ...            # do some computation that needs `x` as scratch space\n    return ret, x\nend\n\nalloc = ... # create allocator\nret0, x = myfun1(alloc, input0) # allocates\nret1, _ = myfun1(x, input1)     # `x` is an array => should not allocate\n\nThe point of x being returned is to use it in subsequent calls  and (potentially) avoid new allocations. A slightly different pattern is:\n\nfunction myfun1(tmp::Union{AbstractArray, ArrayAllocator}, input)\n    x = malloc(tmp, ...) # allocate temporary array y, as with `similar(...)`\n    ...\n    ret = ...            # do some computation that needs `x` as scratch space\n    x = mfree(tmp, x)    # `free` array x, in a sense depending on tmp\n    return ret, x\nend\n\nalloc = ... # create allocator\nret0, tmp = myfun1(alloc, input0) # allocates\nret1, _ = myfun1(tmp, input1)     # `tmp` may be an array or an array allocator\n\nThe precise behavior of mfree depends on the concrete type of tmp. mfree(tmp, x) may return the array x or tmp itself. Allocators are allowed to reuse memory passed to mfree for subsequent calls to malloc.  Therefore an array must not be read/written after being passed to mfree.\n\nBeyond arrays, nested (named) tuples arrays are supported. For this, the following behavior  is implemented whenever v::ArrayAllocator\n\n(; x, y, z) = tmp    # results in `x==tmp` etc.\nx, y, z = tmp        # results in `x==tmp` etc.\n@. tmp = expr        # returns `@. expr`\n\nThis enables the following, more advanced pattern:\n\nfunction example(tmp::Union{AbstractArray, ArrayAllocator}, input)\n    ret1, x = myfun1(tmp.x, input)  # uses `mfree`\n    ret2, y = myfun1(tmp.y, input)  # uses `mfree`\n    # we are not allowed to read/write `x` or `y` here since they have been freed\n    # for instance `tmp` may have reused the memory allocated for `x`\n    # when allocating `y`, so that `x` and `y` refer to the same memory !\n    ret = ...            # do some computation with ret1 and ret2\n    return ret, mfree(tmp, (; x,y))\nend\n\nalloc = ... # create allocator\nret0, tmp = myfun1(alloc, input0)  # allocates\nret1, _  = myfun1(tmp, input1)     # `tmp` may be a named tuple of arrays, or an array allocator\n\nSee malloc, mfree , set_dryrun and has_dryrun.\n\n\n\n\n\n","category":"type"},{"location":"#MutatingOrNot.BasicDryRun","page":"Home","title":"MutatingOrNot.BasicDryRun","text":"struct BasicDryRun <: DryRun end\n\nSee DryRun.\n\n\n\n\n\n","category":"type"},{"location":"#MutatingOrNot.BasicVoid","page":"Home","title":"MutatingOrNot.BasicVoid","text":"See void, Void.\n\n\n\n\n\n","category":"type"},{"location":"#MutatingOrNot.DryRun","page":"Home","title":"MutatingOrNot.DryRun","text":"abstract type DryRun<:Void end\n\nInstances v of types subtyping DryDryn, especially dryrun, when passed as an output argument, are meant to signal that this argument needs to be allocated, but that no actual computation should take place. Especially:\n\nhas_dryrun(::DryRun) = true\n\nSee has_dryrun.\n\n\n\n\n\n","category":"type"},{"location":"#MutatingOrNot.SmartAllocator-Tuple{}","page":"Home","title":"MutatingOrNot.SmartAllocator","text":"smart = SmartAllocator()\n\nReturn a smart allocator smart, with the following behavior:\n\ninternally, smart maintains a store tracking previously allocated arrays,  marked as either busy or free.\ny = malloc(smart, args...) searches that store for an array  with the appropriate eltype and shape. If this fails,  it allocates one with similar(args...). Either way, y is marked as busy in the store.\nmfree(smart, y) keeps y in the store and marks it as free, so that a later call to malloc can reuse it\nany mfree must have a corresponding malloc\nmfree(smart) marks all arrays in the store as free but does not actually free anything.\nonly empty!(smart) actually empties the store, allowing Julia's garbage collector to act. \n\nNote of caution:\n\narrays from the store are reused only if they have the exact same eltype and shape as requested by malloc.\nto avoid runaway memory usage, any malloc must have a corresponding mfree\nthis allocator is smart only if the eltype and shape requested via malloc belong to a small set of possibilities.\n\n\n\n\n\n","category":"method"},{"location":"#MutatingOrNot.Void","page":"Home","title":"MutatingOrNot.Void","text":"abstract type Void <: ArrayAllocator end\n\nInstances of types subtyping Void, especially void, when passed as an output argument, are meant to signal that this argument is not allocated, and needs to be. The aim is to implement both mutating and non-mutating styles in a single place, while facilitating the pre-allocation of output arguments before calling the mutating, non-allocating variant.\n\nMore specifically:\n\nmalloc(::Void, args...) = similar(args...)\nmfree(::Void, x) = x\n\nSee ArrayAllocator, malloc, mfree , set_dryrun and has_dryrun. See also void, dryrun\n\n\n\n\n\n","category":"type"},{"location":"#MutatingOrNot.has_dryrun-Tuple{Any}","page":"Home","title":"MutatingOrNot.has_dryrun","text":"When tmp::ArrayAllocator, has_dryrun(tmp)==true signals that only allocations should take place, but not actual work (computations). Furthermore:\n\nhas_dryrun(x) == any(has_dryrun, x) # if `x` is a (named) tuple\nhas_dryrun(x) == false              # if `x` is an array\n\nUse it to avoid computations when only allocations are desired. Example:\n\nfunction f!(tmp, x, y)\n    # allocations, if needed\n    a = malloc(tmp.a, x)   # same type and shape as `x`\n    b = malloc(tmp.b, y)   # same type and shape as `y`\n\n    # early exit, if requested\n    has_dryrun(x) && return (; a, b)\n\n    # computations\n    a = @. a = y*y\n    b = @. b = exp(z)\n    return (; a, b)\nend\n\nIn the above example,\n\nthe special properties of x_::Void (see Void) are used\nx = f!(void, y) is the non-mutating variant of f!\nx = f!(dryrun, y) just allocates x, without performing actual work\nx = f!(x, y) mutates the pre-allocated x (non-allocating)\n\n\n\n\n\n","category":"method"},{"location":"#MutatingOrNot.malloc-Tuple{Any, Vararg{Any}}","page":"Home","title":"MutatingOrNot.malloc","text":"x = malloc(tmp, args...)\n\nWhen tmp::ArrayAllocator, return array x, similarly to similar(args...). The allocator tmp may provide more or less sophisticated allocation strategies.\n\nOtherwise, especially when tmp is an array or a (nested) (named) tuple thereof, return tmp itself. The goal is to allocate x only when a pre-allocated tmp is not provided.\n\nSee void and SmartAllocator.\n\n\n\n\n\n","category":"method"},{"location":"#MutatingOrNot.malloc_void-Tuple","page":"Home","title":"MutatingOrNot.malloc_void","text":"x = malloc_void(args...)\n\nmalloc_void(args...) defaults to similar(y...). Furthermore the single-argument malloc_void(y) applies recursively to tuples and named tuples. Contrary to similar, it is not possible to specify eltype or dims in this recursive variant.\n\n\n\n\n\n","category":"method"},{"location":"#MutatingOrNot.mfree-Tuple{Any, Any}","page":"Home","title":"MutatingOrNot.mfree","text":"mfree(tmp, x)\n\nFree array x, which was previously allocated by malloc(tmp, ...). Whether anything is actually done depends on the allocator tmp.  See void and SmartAllocator.\n\n\n\n\n\n","category":"method"},{"location":"#MutatingOrNot.mfree-Tuple{Any}","page":"Home","title":"MutatingOrNot.mfree","text":"mfree(tmp)\n\nFree allocator tmp. Whether anything is actually done depends on the allocator tmp. See void and SmartAllocator.\n\n\n\n\n\n","category":"method"},{"location":"#MutatingOrNot.set_dryrun","page":"Home","title":"MutatingOrNot.set_dryrun","text":"dryrun_tmp = set_dryrun(tmp)\n\nReturn allocator dryrun_tmp with the same behavior as tmp except that has_dryrun(dryrun_tmp)==true.\n\n\n\n\n\n","category":"function"}]
}
